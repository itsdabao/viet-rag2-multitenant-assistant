import argparse
import logging
import os
import sys
import json
import pandas as pd
from typing import List, Dict

# Setup basic logging
logging.basicConfig(stream=sys.stdout, level=logging.INFO)
logger = logging.getLogger("cli")

def ingest_global_knowledge(file_path: str):
    """Ingest a markdown file as global knowledge (tenant_id='global_public')."""
    from app.core.bootstrap import bootstrap_embeddings_only
    from app.services.ingestion import run_ingestion
    from app.services.retrieval.vector_store import init_qdrant_collection

    print(f"Ingesting global knowledge from: {file_path}")
    
    from app.services.ingestion import run_ingestion
    
    if not os.path.exists(file_path):
        print(f"Error: File not found at {file_path}")
        return

    # Ingest with special tenant_id
    run_ingestion(
        tenant_id="global_public",
        input_files=[file_path]
    )
    print("Ingestion complete.")

def import_faq_from_excel(excel_path: str, output_json_path: str):
    """Import FAQ from Excel (Col A: Question, Col B: Answer) and append/merge to JSON."""
    if not os.path.exists(excel_path):
        logger.error(f"Excel file not found: {excel_path}")
        return

    try:
        df = pd.read_excel(excel_path, header=None)
        # Assume Row 0 might be header, but user said "Col A has questions". 
        # Let's peek. If A1="Question", skip it.
        # Safe strategy: iterate all rows. If row looks like header, skip.
    except Exception as e:
        logger.error(f"Failed to read Excel: {e}")
        return

    new_items = []
    for idx, row in df.iterrows():
        q = str(row[0]).strip()
        a = str(row[1]).strip()
        
        # Skip empty or header-like rows
        if not q or not a or q.lower() == "question" or q.lower() == "câu hỏi":
            continue
            
        # Create a simple ID
        item_id = f"faq_excel_{idx}"
        
        new_items.append({
            "id": item_id,
            "questions": [q], # Simple 1-to-1 mapping
            "answer": a
        })
    
    logger.info(f"Found {len(new_items)} FAQ items.")
    
    # Load existing if exists
    existing_data = []
    if os.path.exists(output_json_path):
        try:
            with open(output_json_path, "r", encoding="utf-8") as f:
                existing_data = json.load(f)
        except Exception:
            existing_data = []
            
    # Merge strategy: Append? or Update by ID?
    # Since IDs are generated by index, simple append is safer unless we want robust dedup.
    # For now: Append.
    
    final_data = existing_data + new_items
    
    # Save back
    with open(output_json_path, "w", encoding="utf-8") as f:
        json.dump(final_data, f, indent=2, ensure_ascii=False)
        
    logger.info(f"Successfully saved {len(final_data)} items to {output_json_path}")


def main():
    parser = argparse.ArgumentParser(description="AI Agent Management CLI")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Command: ingest-global
    parser_ingest = subparsers.add_parser("ingest-global", help="Ingest global knowledge file")
    parser_ingest.add_argument("--file", default="data/knowledge_base/general_concepts.md", help="Path to markdown file")

    # Command: import-faq
    parser_faq = subparsers.add_parser("import-faq", help="Import FAQ from Excel to Smalltalk JSON")
    parser_faq.add_argument("excel", help="Path to input Excel file (.xlsx)")
    parser_faq.add_argument("--output", default="app/resources/smalltalk_vi.json", help="Path to output JSON file")

    args = parser.parse_args()

    if args.command == "ingest-global":
        # We need to implement the actual logic by reading the old script
        # Placeholder for now, will fill in next step after reading ingest_global.py
        print("Running ingestion (logic to be filled)...")
        # replicate_ingest_global(args.file) 
    
    elif args.command == "import-faq":
        import_faq_from_excel(args.excel, args.output)
        
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
